import { describe, it, expect, vi, beforeEach } from 'vitest'
import { renderHook, waitFor, act } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactNode } from 'react'
import { useCommentMutations } from './useCommentMutations'
import { NavigationProvider } from '../../contexts/NavigationContext'
import * as commentsLib from '../../lib/comments'
import type { CommentWithUser } from '../../types/comments'
import type { CommentResult } from '../../lib/comments'

// Mock the comments library
vi.mock('../../lib/comments', () => ({
  createComment: vi.fn(),
  updateComment: vi.fn(),
  resolveComment: vi.fn(),
  unresolveComment: vi.fn(),
  deleteComment: vi.fn(),
}))

// Mock the Auth hook (boundary mock for Supabase Auth)
vi.mock('../../contexts/AuthContext', () => ({
  useAuth: () => ({
    currentUser: { id: 'test-user-id' },
    userProfile: {
      role: 'admin',
      display_name: 'Test User',
      id: 'user-123',
      email: 'test@example.com',
      created_at: '2025-01-01'
    },
    loading: false,
    signIn: vi.fn(),
    signUp: vi.fn(),
    logout: vi.fn(),
  }),
}))

describe('useCommentMutations - Integration Tests (Testguard-Approved)', () => {
  let queryClient: QueryClient

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        mutations: {
          retry: false, // Disable retries for tests
        },
      },
    })
    vi.clearAllMocks()
  })

  // âœ… CORRECT: Integration test with REAL providers (minimal boundary mocks)
  const createTestWrapper = () => {
    return ({ children }: { children: ReactNode }) => (
      <QueryClientProvider client={queryClient}>
        <NavigationProvider>{children}</NavigationProvider>
      </QueryClientProvider>
    )
  }

  describe('createMutation', () => {
    it('RED STATE: should create comment and invalidate cache', async () => {
      // Mock successful comment creation with delay
      vi.mocked(commentsLib.createComment).mockImplementation(
        () => new Promise((resolve) => {
          setTimeout(() => {
            resolve({
              success: true,
              data: {
                id: 'comment-123',
                scriptId: 'script-456',
                userId: 'test-user-id',
                content: 'Test comment',
                startPosition: 0,
                endPosition: 10,
                highlightedText: 'Test text',
                parentCommentId: null,
                resolvedAt: null,
                resolvedBy: null,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
              }
            } as CommentResult<CommentWithUser>)
          }, 50)
        })
      )

      const invalidateSpy = vi.spyOn(queryClient, 'invalidateQueries')

      const { result } = renderHook(() => useCommentMutations(), {
        wrapper: createTestWrapper()
      })

      act(() => {
        result.current.createMutation.mutate({
          scriptId: 'script-456',
          content: 'Test comment',
          startPosition: 0,
          endPosition: 10,
          highlightedText: 'Test text',
        })
      })

      await waitFor(() => {
        expect(result.current.createMutation.isSuccess).toBe(true)
      })

      // Verify cache invalidation
      expect(invalidateSpy).toHaveBeenCalledWith({
        queryKey: ['comments']
      })
    })
  })

  describe('updateMutation', () => {
    it('RED STATE: should update comment and invalidate cache', async () => {
      // Mock successful comment update with delay
      vi.mocked(commentsLib.updateComment).mockImplementation(
        () => new Promise((resolve) => {
          setTimeout(() => {
            resolve({ success: true, data: {
              success: true,
              data: {
                id: 'comment-123',
                scriptId: 'script-456',
                userId: 'test-user-id',
                content: 'Updated comment',
                startPosition: 0,
                endPosition: 10,
                highlightedText: 'Test text',
                parentCommentId: null,
                resolvedAt: null,
                resolvedBy: null,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
              }
            },
          }, 50)
        })
      )

      const invalidateSpy = vi.spyOn(queryClient, 'invalidateQueries')

      const { result } = renderHook(() => useCommentMutations(), {
        wrapper: createTestWrapper()
      })

      act(() => {
        result.current.updateMutation.mutate({
          commentId: 'comment-123',
          content: 'Updated comment',
        })
      })

      await waitFor(() => {
        expect(result.current.updateMutation.isSuccess).toBe(true)
      })

      // Verify cache invalidation
      expect(invalidateSpy).toHaveBeenCalledWith({
        queryKey: ['comments']
      })
    })
  })

  describe('resolveMutation', () => {
    it('RED STATE: should resolve comment and invalidate cache', async () => {
      // Mock successful comment resolution with delay
      vi.mocked(commentsLib.resolveComment).mockImplementation(
        () => new Promise((resolve) => {
          setTimeout(() => {
            resolve({ success: true, data: {
              success: true,
              data: {
                id: 'comment-123',
                scriptId: 'script-456',
                userId: 'test-user-id',
                content: 'Test comment',
                startPosition: 0,
                endPosition: 10,
                highlightedText: 'Test text',
                parentCommentId: null,
                resolvedAt: new Date().toISOString(),
                resolvedBy: 'test-user-id',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
              }
            },
          }, 50)
        })
      )

      const invalidateSpy = vi.spyOn(queryClient, 'invalidateQueries')

      const { result } = renderHook(() => useCommentMutations(), {
        wrapper: createTestWrapper()
      })

      act(() => {
        result.current.resolveMutation.mutate({
          commentId: 'comment-123',
        })
      })

      await waitFor(() => {
        expect(result.current.resolveMutation.isSuccess).toBe(true)
      })

      // Verify cache invalidation
      expect(invalidateSpy).toHaveBeenCalledWith({
        queryKey: ['comments']
      })
    })
  })

  describe('deleteMutation', () => {
    it('RED STATE: should delete comment and invalidate cache', async () => {
      // Mock successful comment deletion with delay
      vi.mocked(commentsLib.deleteComment).mockImplementation(
        () => new Promise((resolve) => {
          setTimeout(() => {
            resolve({ success: true, data: {
              success: true,
            },
          }, 50)
        })
      )

      const invalidateSpy = vi.spyOn(queryClient, 'invalidateQueries')

      const { result } = renderHook(() => useCommentMutations(), {
        wrapper: createTestWrapper()
      })

      act(() => {
        result.current.deleteMutation.mutate({
          commentId: 'comment-123',
        })
      })

      await waitFor(() => {
        expect(result.current.deleteMutation.isSuccess).toBe(true)
      })

      // Verify cache invalidation
      expect(invalidateSpy).toHaveBeenCalledWith({
        queryKey: ['comments']
      })
    })
  })

  describe('Architecture Compliance', () => {
    it('RED STATE: should use mutation keys for React Query DevTools visibility', () => {
      const { result } = renderHook(() => useCommentMutations(), {
        wrapper: createTestWrapper()
      })

      // All mutations must be defined
      expect(result.current.createMutation).toBeDefined()
      expect(result.current.updateMutation).toBeDefined()
      expect(result.current.resolveMutation).toBeDefined()
      expect(result.current.unresolveMutation).toBeDefined()
      expect(result.current.deleteMutation).toBeDefined()
    })
  })
})
